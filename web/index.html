<!DOCTYPE html>
<head>
	<title>Hello</title>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="styles.css">
</head>
<body>
	<nav class="game_nav">
		<span id="game_logo">
			Mafia
		</span>
		<button id="lobby_button" onclick="UIToggleLobby(!is_lobby)"></button>
	</nav>
	<div class="game_content">
		<div class="game_box">
			<div id="game_lobby">
				<div class="game_join" style="">
					<label for="game_username"></label>
					<input id="game_username" type="text" autocomplete="off" spellcheck="false" placeholder="Username"></input>
					<button id="join_button" onclick="SendGameJoin()">Join</button>
					<button id="leave_button" onclick="SendGameLeave()" style="display: none;">Leave</button>
					<button id="ready_button" onclick="SendGameReady()" style="display: none;"></button>
				</div>
				<div style="display: flex; margin: 8px;">
					<span id="game_join_error" style="color: tomato;"></span>
					<span id="players_none" style="color: var(--text-muted);">No players yet...</span>
				</div>
				<div id="players_list">
				</div>
				<hr>
				<div style="display: flex;">
					<span>Viewers:</span>&nbsp;<span id="game_viewers">?</span>
				</div>
				<div class="box">
				</div>
			</div>
			<div id="game_chat">
				<div id="game_chat_content">
				</div>
				<hr>
				<div id="game_chat_under">
				</div>
				<div id="game_chat_timer">
				</div>
			</div>
		</div>
	</div>
	<script src="gmt.js"></script>
	<script src="utils.js"></script>
	<script src="templates.js"></script>
	<script>
		// --- Variables ---
		var ready = false;
		var ready_next = false;
		var player_names = [];
		var player_states = "";
		var player_dead = "";
		var player_next_count = 0;
		var game_started = false;
		var is_lobby = true;
		var player_role = -1;
		var is_player = false;
		var player_index = -1;
		// --- Elements ---
		const viewersEl = document.getElementById("game_viewers");
		const logoEl = document.getElementById("game_logo");
		const playersListEl = document.getElementById("players_list");
		const usernameEl = document.getElementById("game_username");
		const joinErrorEl = document.getElementById("game_join_error");
		const readyButtonEl = document.getElementById("ready_button");
		const lobbyButtonEl = document.getElementById("lobby_button");
		const gameLobby = document.getElementById("game_lobby");
		const gameChat = document.getElementById("game_chat");
		const gameChatContent = document.getElementById("game_chat_content");
		const gameChatUnder = document.getElementById("game_chat_under");
		const gameChatTimer = document.getElementById("game_chat_timer");
		// --- UI Handlers ---
		lobbyButtonEl.addEventListener("keydown", function(event) {
			if (event.key === "Enter") {
				event.preventDefault();
				
			}
		});
		UIToggleLobby(true);
		UIToggleReady(false);
		function UIToggleLobby(state) {
			if (state) {
				gameChat.style.display = "none";
				gameLobby.style.display = "unset";
				lobbyButtonEl.innerHTML = "To game";
			} else {
				gameChat.style.display = "unset";
				gameLobby.style.display = "none";
				lobbyButtonEl.innerHTML = "To lobby";
			}
			is_lobby = state;
		}
		function UIToggleJoin(state) {
			if (state) {
				document.getElementById("join_button").style.display  = "none";
				document.getElementById("leave_button").style.display = "unset";
				document.getElementById("ready_button").style.display = "unset";
				usernameEl.disabled = true;
			} else {
				document.getElementById("join_button").style.display  = "unset";
				document.getElementById("leave_button").style.display = "none";
				document.getElementById("ready_button").style.display = "none";
				usernameEl.disabled = false;
			}
		}
		function UIToggleReady(state) {
			ready = state;
			document.getElementById("ready_button").innerHTML = !ready ? "Ready" : "Not ready";
		}
		function UIClearChatUnder() {
			gameChatUnder.innerHTML = "";
		}
		function UIPollSpawn() {
			UIPollDelete();
			if (player_dead[player_index] == '0') {
				gameChatUnder.innerHTML += eval(`\`${templGamePoll}\``)
			}
		}
		function UIPollDelete() {
			var pollButton = document.getElementById("game_poll");
			if (pollButton) { readyNextButton.remove(); }
		}
		function UIReadyNextButtonSpawn() {
			UIReadyNextButtonDelete();
			gameChatUnder.innerHTML += templReadyNextButton;
		}
		function UIReadyNextButtonUpdate() {
			const readyNextButton = document.getElementById("ready_next_button");
			if (!readyNextButton) { return; }
			ready_next_button.disabled = !is_player || player_dead[player_index] == '1';
			readyNextButton.innerHTML = `${ready_next ? "Not ready" : "Ready"} (${player_next_count}/${player_dead.split('0').length-1})`;
		}
		function UIReadyNextButtonDelete() {
			var readyNextButton = document.getElementById("ready_next_button");
			if (readyNextButton) { readyNextButton.remove(); }
		}
		// --- Server Message Send ---
		function SendGameJoin() {
			const writer = new ByteWriter();
			writer.u8(GCMT.LOBBY_JOIN);
			writer.strn(usernameEl.value);
			ws.send(writer.bytes())
		}
		function SendGameLeave() {
			const writer = new ByteWriter();
			writer.u8(GCMT.LOBBY_LEAVE);
			ws.send(writer.bytes())
		}
		function SendGameReady() {
			const writer = new ByteWriter();
			UIToggleReady(!ready);
			writer.u8(GCMT.LOBBY_READY);
			writer.u8(ready);
			ws.send(writer.bytes())
		}
		function SendGameReadyNext() {
			const writer = new ByteWriter();
			ready_next = !ready_next;
			writer.u8(GCMT.READY_NEXT);
			ws.send(writer.bytes())
		}
		function SendGamePoll(index) {
			const writer = new ByteWriter();
			writer.u8(GCMT.POLL);
			writer.u32(index);
			ws.send(writer.bytes())
		}
		// --- Generate HTML --- // TODO: move up
		function GeneratePoll() {
			var s = "";
			for (const i in player_names) {
				var dis = player_dead[i] == "1" ? "disabled" : ""
				var pname = player_names[i]
				s += `<button ${dis} onclick="SendGamePoll(${i})">${pname}</button>`
			}
			return s;
		}
		function GetPlayerStatus(i) {
			var stat = "";
			if (player_states[i] != "0") { stat = "(ready)"; }
			if (player_dead[i] != "0") { stat = "(dead)"; }
			return stat;
		}
		// --- Server Message Handlers ---
		function HandleServerInfoPlayer(reader) {
			ready_next = reader.u8();
		}
		function HandleServerInfoUsers(reader) {
			const viewer_count = reader.u32();
			const player_count = reader.u32();
			player_names = reader.strn().split('\0');
			player_states = reader.strn();
			player_dead = reader.strn();
			player_names.pop();
			playersListEl.innerHTML = "";
			const playersNoneEl = document.getElementById("players_none");
			playersNoneEl.style.display = player_names.length == 0 ? "unset" : "none";
			for (const i in player_names) {
				playersListEl.innerHTML += eval(`\`${templPlayerListEntry}\``);
			}
			viewersEl.textContent = viewer_count;
		}
		function HandleServerInfoReadyNext(reader) {
			const all_ready = reader.u8();
			player_next_count = reader.u32();
			if (all_ready) { ready_next = false; }
			UIReadyNextButtonUpdate();
		}
		function HandleServerGameAction(reader) {
			const action = reader.u8();
			var msgEl = document.createElement('div');
			msgEl.className = "game_chat_msg";
			switch (action) {
				case GAT.CLEAR:
					gameChatContent.innerHTML = "";
					return;
				case GAT.STARTED:
					logoEl.innerHTML = "Mafia (game started)";
					player_index = -1;
					readyButtonEl.disabled = true;
					game_started = true;
					UIToggleLobby(false);
					readyButtonEl.style.display = "none";
					msgEl.innerHTML += templGameStarted;
					if (is_player) {
						msgEl.innerHTML += templGameStartedPlayerNote;
					} else {
						msgEl.innerHTML += templGameStartedSpectatorNote;
					}
					break;
				case GAT.ROLE:
					const role_type = reader.u8();
					player_index = reader.u32();
					player_role = role_type;
					role_name = "";
					switch (player_role) {
						case GRT.TOWNSMAN: role_name += templRoleVillager; break;
						case GRT.MAFIA:    role_name += templRoleMafia; break;
						case GRT.SERIF:    role_name += templRoleSerif; break;
						case GRT.DOCTOR:   role_name += templRoleDoctor; break;
						case GRT.ESCORT:   role_name += templRoleEscort; break;
						case GRT.MANIAC:   role_name += templRoleManiac; break;
					}
					msgEl.innerHTML += eval(`\`${templGameActionRole}\``);
					break;
				case GAT.DAY_STARTED:
					UIClearChatUnder();
					msgEl.innerHTML += templDayStarted;
					UIReadyNextButtonSpawn();
					break;
				case GAT.DAY_ENDED:
					UIReadyNextButtonSpawn();
					break;
				case GAT.NIGHT_STARTED:
					UIClearChatUnder();
					msgEl.innerHTML += templNightStarted;
					if (!is_player) {
						msgEl.innerHTML += templChoicesNote;
					}
					break;
				case GAT.NIGHT_ROLE_ACTION:
					var role = reader.u8();
					msgEl.innerHTML += templRoleTasks[role];
					switch (role) {
						case GRT.TOWNSMAN:
							break;
						case GRT.MAFIA:
							break;
						case GRT.SERIF:
							break;
						case GRT.DOCTOR:
							break;
						case GRT.ESCORT:
							break;
						case GRT.MANIAC:
							break;
					}
					UIReadyNextButtonSpawn();
					break//;
				case GAT.POLL:
					UIPollSpawn();
					UIReadyNextButtonSpawn();
					break;
				case GAT.POLL_CHOSE:
					role = reader.u8();
					voter_index = reader.u32();
					chosen_index = reader.u32();
					msgEl.innerHTML += eval(`\`${templRoleChose[role]}\``)
					break;
				case GAT.PLAYER_KILLED:
					chosen_index = reader.u32();
					msgEl.innerHTML += eval(`\`${templPlayerKilled}\``)
					break;
				case GAT.PLAYER_CHECKED:
					chosen_index = reader.u32();
					role = reader.u8();
					msgEl.innerHTML += eval(`\`${templPlayerChecked}\``)
					break;
				case GAT.PLAYER_HEALED:
					chosen_index = reader.u32();
					msgEl.innerHTML += eval(`\`${templPlayerHealed}\``)
					break;
				case GAT.PLAYER_CHECKED:
					chosen_index = reader.u32();
					msgEl.innerHTML += eval(`\`${templPlayerStunned}\``)
					break;
				case GAT.PLAYER_KICKED:
					chosen_index = reader.u32();
					msgEl.innerHTML += eval(`\`${templPlayerKicked}\``)
					break;
				case GAT.PLAYER_STUNNED:
					chosen_index = reader.u32();
					msgEl.innerHTML += eval(`\`${templPlayerStunned}\``)
					break;
				case GAT.MAFIA_WON:
					msgEl.innerHTML += "<h1>MAFIA WON</h1>"
					msgEl.innerHTML += "<p>You can reload the page!</p>"
					logoEl.innerHTML = "Mafia (game ended)";
					break;
				case GAT.TOWN_WON:
					msgEl.innerHTML += "<h1>TOWN WON</h1>"
					msgEl.innerHTML += "<p>You can reload the page!</p>"
					logoEl.innerHTML = "Mafia (game ended)";
					break;
				case GAT.MANIAC_WON:
					msgEl.innerHTML += "<h1>MANIAC WON</h1>"
					msgEl.innerHTML += "<p>You can reload the page!</p>"
					logoEl.innerHTML = "Mafia (game ended)";
					break;
				case GAT.RESULTS:
					msgEl.innerHTML += "";
					break;
				// TODO: on end:
				// readyButtonEl.disabled = false;
				// game_started = false;
				// UIToggleLobby(true);
				default:
					return;
			}
			gameChatContent.appendChild(msgEl);
			UIReadyNextButtonUpdate();
		}
		function HandleServerGameConfirm(reader) {
			confirm_type = reader.u8();
			switch (confirm_type) {
				case GC.JOIN_SUCCESS:
					joinErrorEl.innerHTML = "";
					UIToggleJoin(true);
					UIToggleReady(false);
					is_player = true;
					break;
				case GC.LEAVE_SUCCESS:
					joinErrorEl.innerHTML = "";
					UIToggleJoin(false);
					UIToggleReady(false);
					is_player = false;
					break;
			}
		}
		function HandleServerGameError(reader) {
			err_type = reader.u8();
			switch (err_type) {
				case GE.JOIN_GAME_IN_PROGRESS:
				case GE.LEAVE_GAME_IN_PROGRESS:
					joinErrorEl.innerHTML = "Game already started";
					break;
				case GE.JOIN_NAME_TOO_LONG:
					joinErrorEl.innerHTML = "Name too long";
					break;
			}
		}
		function HandleServerGameTimer(reader) {
			time_remaning = reader.u32();
			gameChatTimer.innerHTML = "Timer: " + time_remaning;
		}
		// --- WebSockets ---
		const ws = new WebSocket(`ws://${location.host}/ws`);
		ws.binaryType = "arraybuffer";
		ws.onopen = () => {
			//console.log('WS: open');
		};
		ws.onmessage = (event) => {
			const reader = new ByteReader(event.data);
			msg_type = reader.u8();
			switch (msg_type) {
				case GSMT.INFO_PLAYER:     HandleServerInfoPlayer(reader); break;
				case GSMT.INFO_USERS:      HandleServerInfoUsers(reader); break;
				case GSMT.INFO_READY_NEXT: HandleServerInfoReadyNext(reader); break;
				case GSMT.ERROR:           HandleServerGameError(reader); break;
				case GSMT.CONFIRM:         HandleServerGameConfirm(reader); break;
				case GSMT.GAME_ACTION:     HandleServerGameAction(reader); break;
				case GSMT.HISTORY_END:     gameChatUnder.scrollIntoView(); break;
				case GSMT.TIMER:           HandleServerGameTimer(reader); break;
			}
		}
	</script>
</body>
